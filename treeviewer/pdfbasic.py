"""
a simple module to parse simple PDF generated from R's plot.dendrogram function
so that we can map the user click to subtree's or labels.

Typical usage (found in the shortcut function `process_pdf'):

	labels = get_labels(filepath='test.pdf')
	t = build_tree(get_L_shape(get_lines(filepath='test.pdf')))
	match_points_to_tree(t, labels)
	tt = serialize_tree(t)
"""
import os
import shutil
import re
from copy import copy

leaf_pattern = re.compile(r"([-0-9.]+) ([-0-9.]+) Tm \(([a-zA-Z0-9_:.]+)\) Tj")
point_pattern = re.compile(r"/F1 1 Tf 1 Tr [-0-9.]+ [-0-9.]+ [-0-9.]+ [-0-9.]+ ([-0-9.]+) ([-0-9.]+) Tm \(l\) Tj 0 Tr")
stream_rec_pattern = re.compile(r"0 0 ([-0-9.]+) ([-0-9.]+) re f")
line_pattern = re.compile(r"([-0-9.]+) ([-0-9.]+) m ([-0-9.]+) ([-0-9.]+) l S")

# decorator
def filepath_or_fileobject(func):
	"""
	a decorator to process argument: either f(a file object) or filepath
	(path to a file) must be provided. The decorated function can assume
	f is always provided and ignore filepath
	"""
	def decorated(f=None, filepath=None, *args, **kargs):
		assert f is None or filepath is None
		assert not (f is None and filepath is None)
		if f is None:
			f = file(filepath)
		return func(f, filepath, *args, **kargs)
	return decorated

def increase_width(filepath, overwrite=False):
	"""
	take a pdf filepath, this function changes the bounding box size
	and save it to a new file
	"""
	tempfile = os.path.dirname( filepath ) + '/chemmine_' + \
				 os.path.basename( filepath )
	line_prefix = '/MediaBox [0 0 '
	width = None
	height = None
	created = True
	if os.path.exists(tempfile):
		if overwrite:
			of = file(tempfile, 'w')
		else:
			created = False
			of = file('/dev/null', 'w')
	else:
		of = file(tempfile, 'w')

	for i in file(filepath):
		m = stream_rec_pattern.match(i)
		if m:
			width, height = float(m.group(1)), float(m.group(2))
			width *= 2
			if width > height: height = width
			of.write("0 0 %.2f %.2f re f\n" % (width, height))
		elif i.startswith(line_prefix):
			width, height = i[len(line_prefix):].strip()[:-1].split()
			width = int(width) * 2
			height = int(height)
			of.write("%s%d %d]\n" % (line_prefix, width, height))
		else:
			of.write(i)
	of.close()

	if width is None:
		if created: os.unlink(tempfile)
		raise Exception("Cannot find width/height line")

	return width, height, tempfile

@filepath_or_fileobject
def get_labels(f=None, filepath=None, compounds=None):
	"""
	take a PDF file, it will return points corresponding to all labels		(x, y, label, url)
	compounds is ChemMine workbench's smilescompound in the session
	"""
	points = []
	for ln in f:
		m = leaf_pattern.search(ln)
		if m:
			url = ''
			starred = ''
			#if compounds and m.group(3) not in compounds:
			#	continue
			if compounds and m.group(3) in compounds:
				url = compounds[m.group(3)].url or ''
				starred = compounds[m.group(3)].starred
			p = Point(float(m.group(1)), float(m.group(2)))
			p.data = dict(label=m.group(3), url=url, starred=starred)
			points.append(p)
	return points

@filepath_or_fileobject
def get_points(f=None, filepath=None, coords=[], compounds=None):
	"""
	Similar to get_labels, but process PDF generated by plot and points.
	take a PDF file, it will return points corresponding to all labels
		(x, y, label, url)
	compounds is ChemMine workbench's smilescompound in the session
	"""
	points = []
	coord_points = []
	for ln in f:
		m = point_pattern.match(ln)
		if m:
			p = Point(float(m.group(1)), float(m.group(2)))
			points.append(p)
	points.sort()
	
	for c in coords:
		p = Point(c[0], c[1])
		p.data = dict(label=c[2])
		coord_points.append(p)
	coord_points.sort()
	assert len(coord_points) == len(points)
	_points = []
	for i, p in enumerate(points):	
			url = ''
			starred = ''
			label = coord_points[i].data['label']
			#if compounds and label not in compounds:
			#	continue
			if compounds and label in compounds:
				url = compounds[label].url or ''
				starred = compounds[label].starred
			p.data = dict(label=label, url=url, starred=starred)
			_points.append(p)
	return _points

def pdf_size(filepath):
	line_prefix = '/MediaBox [0 0 '
	for i in file(filepath):
		if i.startswith(line_prefix):
			width, height = i[len(line_prefix):].strip()[:-1].split()
			return float(width), float(height)

def serialize_labels(labels):
	"""
	take a list of lables (instances of Point class), serialize it to
	a list of tuples:
	(x, y, data_dict)
	"""
	return [(i.x, i.y, i.data) for i in labels]

class Point(object):
	"""a simple Point class"""
	def __init__(self, x, y, data=None):
		self.x = x
		self.y = y
		self.data = data
	def __eq__(self, other):
		return self.x == other.x and self.y == other.y
	def __ne__(self, other):
		return not self == other
	def __str__(self):
		return "(%s,%s)" % (self.x, self.y)
	def __repr__(self):
		return str(self)
	def __lt__(self, other):
		if self.x != other.x: return self.x < other.x
		else: return self.y < other.y
	def __le__(self, other):
		return self == other or self < other
	def __gt__(self, other):
		if self.x != other.x: return self.x > other.x
		else: return self.y > other.y
	def __ge__(self, other):
		return self == other or self > other

class Line(object):
	"""
	A simple Line class. Each instance have the following attributes:
	- start, a point
	- end, a point
	only supports horizontal and vertical lines
	"""
	def __init__(self, lx, ly, ex, ey):
		"""will always go left to right, and top to bottom"""
		if lx == ex: self.vertical = True
		else: self.vertical = False
		if ly == ey: self.horizontal = True
		else: self.horizontal = False
		if lx != ex and ly != ey:
			raise Exception("can only support vertical and horizontal lines")
		if lx > ex:
			tmp = ex
			ex = lx
			lx = tmp
		if ly > ey:
			tmp = ey
			ey = ly
			ly = tmp
		self.start = Point(lx, ly)
		self.end = Point(ex, ey)
	def __str__(self):
		if self.vertical:
			return "%s|%s" % (self.start, self.end)
		else:
			return "%s-%s" % (self.start, self.end)
	def __repr__(self):
		return str(self)

class TreeNode(object):
	"""
	A simple tree node, each having the following attributes:
	- coord: the point for this node
	- top: top subtree as another instance of the same class
	- bottom: bottom subtree as a nother instance of the same class
	- parent: the parent as another instance of the same class
	- data: any data. Here we use it to contain the list of labels under
	        the subtree
	"""
	def __init__(self, point):
		self.coord = point
		self.top = None
		self.bottom = None
		self.parent = None
		self.data = None
	def add_branch(self, branch):
		assert branch.coord.x >= self.coord.x
		if branch.coord.y > self.coord.y:
			if self.top:
				raise Exception("already have top branch")
			self.top = branch
			branch.parent = self
		else:
			if self.bottom:
				raise Exception("already have bottom branch")
			self.bottom = branch
			branch.parent = self
	def is_leaf(self):
		return not self.top and not self.bottom
	def is_root(self):
		return not self.parent
	def is_healthy(self):
		return self.top and self.bottom

	def plot(self, indent=0):
		if self.top: self.top.plot(indent + 1)
		print "-"*indent + str(self.coord)
		if self.bottom: self.bottom.plot(indent + 1)

class LShape(object):
	"""A simple L Shape class. Each having two points: me and other"""
	def __init__(self, p1, p2):
		if p1.x > p2.x:
			_ = p1
			p1 = p2
			p2 = _
		self.me = p1
		self.other = p2
		
@filepath_or_fileobject
def get_lines(f=None, filepath=None):
	"""read all lines from the PDF"""
	lines = []
	for ln in f:
		m = line_pattern.match(ln)
		if m:
			lx, ly, ex, ey = [float(i) for i in m.groups()]
			lines.append(Line(lx, ly, ex, ey))
	return lines


def get_L_shape(lines):
	"""
	pass in lines, and return all L shapes formed by these lines
	this function only checks 2 L shapes: |_ and |^
	We did this in two rounds. First, try connecting neighboring
	lines, because an L shape is drawed by two continuous line draws.
	Then for any unmatched line, try the brutal force search
	"""
	l_shapes = []

	# round 1
	i = 0
	unmatched_lines = []
	while i < len(lines) - 1:
		line1, line2 = lines[i], lines[i + 1]
		if line1.end == line2.start:
			l_shapes.append( LShape(line1.start, line2.end) )
			i += 2
		elif line1.start == line2.start:
			l_shapes.append( LShape(line1.end, line2.end) )
			i += 2
		elif line1.start == line2.end:
			l_shapes.append( LShape(line1.end, line2.start) )
			i += 2
		elif line1.end == line2.end:
			l_shapes.append( LShape(line1.start, line2.start) )
			i += 2
		else:
			unmatched_lines.append(line1)
			i += 1

	# round 2
	for i in unmatched_lines:
		if i.horizontal: continue
		for j in unmatched_lines:
			if j.vertical: continue
			if i.end == j.start:
				l_shapes.append( LShape(i.start, j.end) )
			elif i.start == j.start:
				l_shapes.append( LShape(i.end, j.end) )
	return l_shapes

def build_tree(l_shapes):
	"""build tree from l_shapes. Return the root node"""
	nodes = dict()
	for i in l_shapes:
		if str(i.me) not in nodes:
			nodes[str(i.me)] = TreeNode(i.me)
		if str(i.other) not in nodes:
			nodes[str(i.other)] = TreeNode(i.other)
	for i in l_shapes:
		nodes[str(i.me)].add_branch(nodes[str(i.other)])
	for i in nodes.values():
		if i.is_root() and i.is_healthy():
			return i

def match_points_to_tree(tree, points):
	"""
	match the label coordinate points to tree so that tree internal
	nodes and leaves are matched to multiple or one leaf labels
	"""
	all_leaves = []
	matched_points = []
	def collect_leaves(node):
		if node.is_leaf(): all_leaves.append(node)
		else:
			collect_leaves(node.top)
			collect_leaves(node.bottom)
	collect_leaves(tree)
	for i in all_leaves:
		y = i.coord.y
		bs = None		# best so far
		for j in points:
			if bs is None or abs(j.y - y) < abs(bs.y - y):
				bs = j
		matched_points.append(bs)
		i.data = bs.data
		i.data['height'] = 0
	# now populate data at leaf nodes to internal nodes. To save space
	# only aggregated info (number of labels under subtree rooted at
	# this internal node) will be recorded
	def populate_data(node):
		if node.is_leaf(): return dict(n_leaves=1,
			repr_leaf=node.data['label'], height=0)
		else:
			t = 0
			topdata = populate_data(node.top)
			t += topdata['n_leaves']
			t += populate_data(node.bottom)['n_leaves']
			node.data = dict(n_leaves=t,
				repr_leaf=topdata['repr_leaf'], height=topdata['height']+1)
			return node.data
	populate_data(tree)

	return matched_points

def serialize_tree(tree):
	"""
	take a tree with data on nodes, serialize it so that it can be jsonized.
	The output format is a list of tuple of the following format:

	[coord_x, coord_y, top_subtree_idx, bottom_subtree_idx, data_dict]
	
	"""
	all = []
	def ser_subtree(node):
		if node.is_leaf():
			all.append(
			  (node.coord.x, node.coord.y, None, None, node.data)
			)
			return len(all) - 1
		top = ser_subtree(node.top)
		bottom = ser_subtree(node.bottom)
		all.append(
		  (node.coord.x, node.coord.y, top, bottom, node.data)
		)
		return len(all) - 1
	ser_subtree(tree)
	return all
		
# shortcut
def process_pdf(pdffile, compounds=None):
	labels = get_labels(filepath=pdffile, compounds=compounds)
	t = build_tree(get_L_shape(get_lines(filepath=pdffile)))
	p = match_points_to_tree(t, labels)
	return serialize_labels(p), serialize_tree(t)
	
# process PDF generated by calling R's points(.,.)
def process_plot(pdffile, coordfile=None, compounds=None):
	import csv
	coords = []
	cr = csv.reader(file(coordfile))
	cr.next()
	for i in cr:
		coords.append([float(i[1]), float(i[2]), i[0]])
	points = get_points(filepath=pdffile, compounds=compounds,
						coords=coords)
	return serialize_labels(points)
